#!/usr/bin/python3
# Flex version: v1.50.77
# April 2, 2024
# For Azure
import argparse
import logging
import os
import re
import subprocess
import yaml
from datetime import datetime
from enum import Enum
from typing import List

date = datetime.now().strftime("%Y%m%d-%H%M%S")
# currently no_proxy is related to azure only
constant_no_proxy = ["localhost", "127.0.0.1", "169.254.169.254", "169.254.170.2", "blob.core.windows.net"]
default_log_dir = "/tmp"


def config_logger(log_dir, debug: bool):
    logging.basicConfig(
        level=logging.DEBUG if debug else logging.INFO,
        format="%(asctime)s [%(levelname)s] %(message)s",
        handlers=[logging.FileHandler(f"{log_dir}/flex-config-{date}.log"), logging.StreamHandler()],
    )
    logging.info(f"Logging to: {log_dir}/flex-config-{date}.log")


class K8sResourceType(Enum):
    deployment = "deployment"
    statefulset = "statefulset"


configmap_types = ["node-types-cm", "service-cm"]


def update_value_in_nested_dict(keys, nested_dict, new_value):
    if not keys:
        return None

    if len(keys) == 1:
        if nested_dict.get(keys[0]):
            if isinstance(nested_dict[keys[0]], dict) or isinstance(nested_dict[keys[0]], list):
                raise ValueError(
                    f"expected to find a value at key: {keys[0]} but found a dictionary/list."
                    f" make sure you passed the correct nested keys"
                )
        nested_dict[keys[0]] = new_value
        return

    value = nested_dict.get(keys[0])
    # If the value is a dictionary, recursively call the function with the remaining keys
    if isinstance(value, dict):
        update_value_in_nested_dict(keys[1:], value, new_value)
    else:
        raise ValueError(
            f"expected to find a dictionary at key: {keys[0]} but found {value}."
            f" make sure you passed the correct nested keys"
        )


def type_bool_converter(val):
    if val in {"true", "True"}:
        return True
    elif val in {"false", "False"}:
        return False
    raise ValueError(f"expected to find a boolean value but found {val}")


def type_converter(val):
    if val in {"true", "True"}:
        return True
    elif val in {"false", "False"}:
        return False
    try:
        val_int = int(val)
        return val_int
    except ValueError:
        try:
            val_float = float(val)
            return val_float
        except ValueError:
            return str(val)


def exec_cmd(cmd, input=None):
    try:
        logging.debug(f"Executing command: {cmd}")
        output = subprocess.check_output(cmd, shell=True, stderr=subprocess.STDOUT, input=input)
        return output
    except subprocess.CalledProcessError as e:
        logging.debug(f"failed to execute command, output: {e.output.decode('utf-8')}")
        raise


def get_cm(cm_name):
    logging.info(f"Getting ConfigMap {cm_name}")
    cmd = f"kubectl get cm {cm_name} -o yaml"
    res = exec_cmd(cmd)
    return yaml.safe_load(res)


def put_cm(configmap_name, config_map):
    logging.info(f"Updating ConfigMap {configmap_name}")
    cmd = f"kubectl apply -f -"
    exec_cmd(cmd, input=yaml.dump(config_map).encode("utf-8"))


def get_node_config_cm_name():
    # configmap name example: node-config-v1.70.18. we have 2 configmaps for node types because of the fully baked.
    # We will take its name from zorg's deployment yaml.
    # cmd = "kubectl get cm --sort-by=.metadata.creationTimestamp | grep node-config | awk '{print $1}' | tail -n 1"
    cmd = """
    kubectl get statefulset zorg \
    -o=jsonpath='{range .spec.template.spec.volumes[?(@.name=="node-config")]}{@.configMap.name}{end}'
    """
    cm_name = exec_cmd(cmd).decode("utf-8").replace("\n", "")
    logging.info(f"Detected following ConfigMap: {cm_name}")
    return cm_name


def add_flex_version_suffix(flex_version):
    """
    if flex_version already has suffix, i.e v1.70.18_1, then we will increment the suffix like so: v1.70.18_2
    if flex_version is still without suffix, i.e v1.70.18, then we will add suffix like so: v1.70.18_1
    """
    pattern = re.compile(r"^(.+)_(\d+)$")
    if pattern.match(flex_version):
        version, suffix = flex_version.split("_")
        suffix = int(suffix) + 1
        return f"{version}_{suffix}"
    else:
        return f"{flex_version}_1"


def update_cm_service(configmap_name: str, path_to_key: List[str], new_value):
    # Get ConfigMap from k8s cluster
    cm = get_cm(configmap_name)
    # Update the specified field
    ms = cm["data"].get("module-settings.yaml")
    ms = yaml.safe_load(ms) if ms else {}
    update_value_in_nested_dict(path_to_key, ms, new_value)
    cm["data"]["module-settings.yaml"] = yaml.dump(ms)
    # Update ConfigMap in k8s cluster
    put_cm(configmap_name, cm)


def update_cm_node_types(configmap_name: str, path_to_key: List[str], new_value):
    """
    get configmap from k8s
    update the specified field + flex_version in order for zorg to update db when it restarts
    update configmap in k8s
    """

    # Get ConfigMap from k8s cluster
    cm = get_cm(configmap_name)
    # Update the specified field
    node_config = yaml.safe_load(cm["data"]["node-config.yaml"])
    update_value_in_nested_dict(path_to_key, node_config, new_value)
    node_config["flex_version"] = add_flex_version_suffix(node_config["flex_version"])
    # Update ConfigMap in k8s cluster
    cm["data"]["node-config.yaml"] = yaml.dump(node_config)
    put_cm(configmap_name, cm)


def update_deployment(env_variables: dict, service_name: str, container_name: str):
    """
    update the deployment with the new environment variables
    """
    logging.info(f"Updating deployment {service_name} with new environment variables")

    cmd = (
        f"kubectl set env deployment/{service_name} --containers='{container_name}'"
        f" {' '.join([f'{k}={v}' for k, v in env_variables.items()])}"
    )
    exec_cmd(cmd)


def update_entity(args):
    if args.entity_type == "node-types-cm":
        configmap_name = get_node_config_cm_name()
        update_cm_node_types(configmap_name, args.path_to_key, args.new_value)
    elif args.entity_type == "service-cm":
        configmap_name = f"hs-conf-{args.service_name}"  # example: hs-conf-explorer
        update_cm_service(configmap_name, args.path_to_key, args.new_value)
    else:  # args.entity_type == K8sResourceType.deployment.value
        update_deployment(args.env_variables, args.service_name, args.container_name)


def restart_service(service_name):
    """
    get number of replicas for the service. it can be a deployment or a statefulset.
    scale the service to 0 and then to number of replicas to restart it.
    """
    logging.info(f"Getting number of replicas for service '{service_name}'")
    k8s_resource_type = K8sResourceType.deployment.value  # service is a deployment or a statefulset

    cmd = f"kubectl get deployment {service_name} -o jsonpath='{{.spec.replicas}}'"
    try:
        num_replicas = exec_cmd(cmd).decode("utf-8")
    except subprocess.CalledProcessError:
        # fallback to statefulset
        cmd = f"kubectl get statefulset {service_name} -o jsonpath='{{.spec.replicas}}'"
        num_replicas = exec_cmd(cmd).decode("utf-8")
        k8s_resource_type = K8sResourceType.statefulset.value

    logging.info(f"Restarting service '{service_name}'")
    cmd = f"""
        kubectl scale --replicas 0 {k8s_resource_type} {service_name} &&
        kubectl scale --replicas {num_replicas} {k8s_resource_type} {service_name}
        """
    exec_cmd(cmd)


def log_directory(val):
    if not val:
        return default_log_dir

    # check is writable directory
    if os.path.isdir(val) and os.access(val, os.W_OK):
        return val

    print(f"{val} is not a valid writable directory")
    raise ValueError(f"{val} is not a valid writable directory")


def proxy_address(val):
    if val.startswith("http://") or val.startswith("https://"):
        return val
    raise ValueError(f"expected to find a proxy address starting with http:// or https:// but found {val}")


def no_proxy_list(val):
    if not val:
        return []
    return val.split(",")


def parse_args():
    parser = argparse.ArgumentParser(
        description="Script to update configmap or deployment in k8s cluster",
        formatter_class=argparse.RawDescriptionHelpFormatter,
        usage=argparse.SUPPRESS,  # to remove the default usage message
    )
    parser.add_argument("--debug", action="store_true", help="Enable debug logging")
    subparsers = parser.add_subparsers(help="")

    parser.add_argument(
        "--log-dir",
        dest="log_dir",
        type=log_directory,
        help=f"Logging directory. default: [{default_log_dir}]",
        default=default_log_dir,
    )

    """==================================== configmap updates ===================================="""

    # for support specific operation of updating nvme verification frequency
    sp = subparsers.add_parser(
        "set-nvme-check-frequency",
        help="frequency of checking sdp's nvme devices by flex",
        formatter_class=argparse.ArgumentDefaultsHelpFormatter,
        epilog="usage example: ./flex-config set-nvme-check-frequency --minutes 500",
    )

    sp.set_defaults(action=set_nvme_check_frequency)
    sp.add_argument(
        "-m",
        "--minutes",
        dest="minutes",
        help="frequency of checking sdp's nvme devices by flex",
        type=int,
        required=True,
    )

    # for support specific operation of updating instance type
    sp = subparsers.add_parser(
        "update-instance-type",
        help="update Azure's instance type",
        formatter_class=argparse.ArgumentDefaultsHelpFormatter,
        epilog="usage example: ./flex-config update-instance-type --instance-type Standard_L32as_v3"
        " --mnode-type Large",
    )

    sp.set_defaults(action=update_instance_type)
    sp.add_argument(
        "-i",
        "--instance-type",
        dest="instance_type",
        help="New instance type value",
        type=str,
        required=True,
    )
    sp.add_argument(
        "-t",
        "--mnode-type",
        dest="mnode_type",
        choices=["Large", "Medium", "Small"],
        help="Mnode type to update",
        type=str,
        required=True,
    )

    # for support specific operation of updating encryption at host enabled/disabled
    sp = subparsers.add_parser(
        "update-encryption-at-host",
        help="update encryption at host enabled/disabled",
        formatter_class=argparse.ArgumentDefaultsHelpFormatter,
        epilog="usage example: ./flex-config update-encryption-at-host --enabled false",
    )
    sp.set_defaults(action=update_encryption_at_host)

    sp.add_argument(
        "-e",
        "--enabled",
        dest="is_encryption_at_host_enabled",
        help="The value of encryption_at_host_enabled in configmap. [true/false]",
        type=type_bool_converter,
        required=True,
    )

    # for internal usage in development or run more specific operations when helping support
    sp = subparsers.add_parser(
        "update-configmap",
        help="Update ConfigMap **for internal developers usage only**",
        formatter_class=argparse.RawDescriptionHelpFormatter,
        epilog="Dev internal usage example:\n"
        "./flex-config update-configmap --configmap-type node-types-cm --path-to-key node_config azure mnodes "
        "Large instance_type --new-value Standard_L32as_v3 --service-name zorg\n"
        "./flex-config update-configmap --configmap-type service-cm --path-to-key "
        "verify_nvme_devices_frequency_minutes --new-value 500 --service-name explorer",
    )
    sp.set_defaults(action=update_configmap)
    sp.add_argument(
        "--configmap-type",
        dest="configmap_type",
        type=str,
        choices=configmap_types,
        help=f"Type of ConfigMap, can be one of {configmap_types}",
        required=True,
    )
    sp.add_argument(
        "--path-to-key",
        dest="path_to_key",
        type=str,
        nargs="+",
        help="list of the keys in path to field to update",
        required=True,
    )
    sp.add_argument(
        "--new-value",
        dest="new_value",
        help="New value for the field",
        type=type_converter,
        required=True,
    )
    sp.add_argument(
        "--service-name",
        dest="service_name",
        type=str,
        help="Name of the service who's configmap we modify",
        required=True,
    )

    """==================================== deployment env updates ================================"""
    deployment_env = subparsers.add_parser(
        "set-env",
        help="set environment variables in deployment",
        formatter_class=argparse.ArgumentDefaultsHelpFormatter,
        epilog="usage example: ./flex-config set-env"
        " --service-name azcloudconnector"
        " --container-name azcloudconnector"
        " --env `http_proxy=http://proxy.io:8000 https_proxy=http://proxy.io:8000`",
    )
    deployment_env.set_defaults(action=set_env)
    deployment_env.add_argument(
        "-s",
        "--service-name",
        dest="service_name",
        type=str,
        help="Name of the deployment to modify",
        required=True,
    )
    deployment_env.add_argument(
        "-c",
        "--container-name",
        dest="container_name",
        default=None,
        type=str,
        help=f"Name of the container who's ENVs should be updated. default [passed service-name]",
        required=False,
    )
    deployment_env.add_argument(
        "-e",
        "--env",
        dest="env_variables",
        type=lambda x: dict([x.split("=")]),
        nargs="+",
        help="Environment variables to set in deployment",
        required=True,
        action="append",
    )
    """==================================== deployment updates ===================================="""
    # for specific operation of adding proxy settings to azcc or claritygw
    sp = subparsers.add_parser(
        "set-proxy-settings",
        help="set proxy settings environment variables in deployment",
        formatter_class=argparse.ArgumentDefaultsHelpFormatter,
        epilog="usage example: ./flex-config set-proxy-settings"
        " --service-name azcloudconnector"
        " --proxy http://proxy.io:8000"
        f" --no-proxy www.example.com,10.8.8.45",
    )
    sp.set_defaults(action=set_proxy_settings)
    sp.add_argument(
        "-p",
        "--proxy",
        dest="proxy_address",
        type=proxy_address,
        help="Address of the proxy server",
        required=True,
    )
    sp.add_argument(
        "-n",
        "--no-proxy",
        dest="no_proxy",
        type=no_proxy_list,
        default="",
        help="additional no_proxy addresses, The passed coma-separated list will be added to"
        f" the default no_proxy: {','.join(constant_no_proxy)}",
        required=False,
    )
    args = parser.parse_args()
    action = getattr(args, "action", None)
    if not action:
        parser.print_help()
        exit(1)
    if action == set_nvme_check_frequency:
        args.entity_type = "service-cm"
        args.path_to_key = ["verify_nvme_devices_frequency_minutes"]
        args.new_value = args.minutes
        args.service_name = "explorer"
    elif action == update_instance_type:
        args.entity_type = "node-types-cm"
        args.path_to_key = ["node_config", "azure", "mnodes", args.mnode_type, "instance_type"]
        args.new_value = args.instance_type
        args.service_name = "zorg"
    elif action == update_encryption_at_host:
        args.entity_type = "service-cm"
        args.path_to_key = ["encryption_at_host_enabled"]
        args.new_value = args.is_encryption_at_host_enabled
        args.service_name = "azcloudconnector"
    elif action == set_env:
        args.entity_type = K8sResourceType.deployment.value
        # [[{'a': 'r'}, {'b': 't'}], [{'l': 'r'}]] -> {'a': 'r', 'b': 't', 'l': 'r'}
        args.env_variables = {k: v for param in args.env_variables for env in param for k, v in env.items()}
        args.container_name = args.container_name or args.service_name
    elif action == update_configmap:
        args.entity_type = args.configmap_type

    return args


def update_k8s_resource(args):
    try:
        update_entity(args)
        restart_service(args.service_name)
        logging.info("Finished update procedure.")
    except subprocess.CalledProcessError as e:
        logging.error(f"procedure failed, output: {e.output.decode('utf-8')}")
    except Exception as e:
        logging.error(f"procedure failed, error: {str(e)}")


def set_nvme_check_frequency(args):
    update_k8s_resource(args)


def set_env(args):
    update_k8s_resource(args)


def update_instance_type(args):
    update_k8s_resource(args)


def update_encryption_at_host(args):
    update_k8s_resource(args)


def update_configmap(args):
    update_k8s_resource(args)


def set_proxy_settings(args):
    _args = lambda x: None

    no_proxy = args.no_proxy + constant_no_proxy
    _args.entity_type = K8sResourceType.deployment.value
    _args.env_variables = {
        "http_proxy": args.proxy_address,
        "https_proxy": args.proxy_address,
        "no_proxy": ",".join(no_proxy),
    }

    for service_name in ["azcloudconnector", "claritygw"]:
        _args.service_name = _args.container_name = service_name
        update_k8s_resource(_args)


def main():
    args = parse_args()
    config_logger(args.log_dir, args.debug)
    args.action(args)


if __name__ == "__main__":
    main()
